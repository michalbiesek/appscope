#define _GNU_SOURCE

#include "sig.h"
#include "errno.h"
#include "scopestdlib.h"
#include "fn.h"
#include "dbg.h"

/*
* Signal timer ID
*/
static timer_t g_sigTimerId = 0;
/*
* Appscope signal handler state (active or not)
*/
static bool g_sigScopeSignalHandler = FALSE;
/*
* Application signal handler state (active or not)
*/
static bool g_sigAppSignalHandler = FALSE;
/*
* Application signal action structure
*/
static struct sigaction g_sigAppAction;

/*
* Distinguish the SIGUSR2 generated by the AppScope library
*/
#define SIGTIMER_SCOPE_ID (123456789)

/*
* Save application handler
*/
void
sigSaveAppAction(const struct sigaction *act) {
    g_sigAppAction.sa_flags = act->sa_flags;
    if (g_sigAppAction.sa_flags & SA_SIGINFO) {
        g_sigAppAction.sa_sigaction = act->sa_sigaction;
    } else {
        g_sigAppAction.sa_handler = act->sa_handler;
    }

    g_sigAppAction.sa_handler = act->sa_handler;
    g_sigAppAction.sa_mask = act->sa_mask;
    g_sigAppSignalHandler = TRUE;
}

/*
* Call application handler
*/
void
sigCallAppAction(int sig, siginfo_t *info, void *secret) {
    if (g_sigAppAction.sa_flags & SA_SIGINFO) {
        g_sigAppAction.sa_sigaction(sig, info, secret);
    } else {
        g_sigAppAction.sa_handler(sig);
    }
}

/*
* Check if AppScope Handler is active
*/
bool
sigIsAppcopeActionActive(void) {
    return g_sigScopeSignalHandler;
}

/*
* Check if Application installed signal Handler
*/
bool
sigIsAppActionInstalled(void) {
    return g_sigAppSignalHandler;
}

/*
* Check if siginfo comes from AppScope signal
*/
bool
sigIsSigFromAppscopeTimer(const siginfo_t *si) {
    if (!si) {
        return FALSE;
    }

    if (si->si_signo != SIGUSR2) {
        return FALSE;
    }

    if (si->si_code != SI_TIMER) {
        return FALSE;
    }

    if (si->si_int != SIGTIMER_SCOPE_ID) {
        return FALSE;
    }

    return TRUE;
}

/*
* Register the signal handler for Appscope
* TODO: Consolidate this with other signals used by the Appscope
*/
bool
sigHandlerRegister(int sigNo, void(*handler)(int, siginfo_t *, void *)) {
    struct sigaction sact;
    sigemptyset(&sact.sa_mask);
    sact.sa_handler = (void (*))handler;
    sact.sa_flags = SA_SIGINFO | SA_RESTART;

    if (!g_fn.sigaction) {
        return FALSE;
    }

    struct sigaction oldact = { 0 };
    if (g_fn.sigaction(sigNo, &sact, &oldact) == -1) {
        DBG("errno %d", errno);
        return FALSE;
    }
    g_sigScopeSignalHandler = TRUE;

    return TRUE;
}

/*
* Starts the "signal timer"
* On timer expiration will generate specific signal
*/
bool
sigTimerStart(int sigNo, unsigned secInterval) {
    struct sigevent sevent = {0};
    struct itimerspec tspec;

    sevent.sigev_notify = SIGEV_SIGNAL;
    sevent.sigev_signo = sigNo;
    sevent.sigev_value.sival_int = SIGTIMER_SCOPE_ID;

    if (timer_create(CLOCK_MONOTONIC, &sevent, &g_sigTimerId) == -1) {
        DBG("errno %d", errno);
        return FALSE;
    }

    tspec.it_interval.tv_sec = 0;
    tspec.it_interval.tv_nsec = 0;
    tspec.it_value.tv_sec = secInterval;
    tspec.it_value.tv_nsec = 0;
    if (timer_settime(g_sigTimerId, 0, &tspec, NULL) == -1) {
        DBG("errno %d", errno);
        return FALSE;
    }
    return TRUE;
}

/*
* Stops the "signal timer"
*/
bool
sigTimerStop(void) {
    if (g_sigTimerId) {
        timer_delete(g_sigTimerId);
        g_sigTimerId = 0;
        return TRUE;
    }

    return FALSE;
}

